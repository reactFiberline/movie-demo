'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerObserver = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _parse = require('../shared/parse');

var _generate = require('../shared/generate');

/**
  This registers an observer that listens to the React performance measurement event.
  It hooks an object containing information about the events and performance measures of React components to the
  global state (window object) which can then be accessed inside the inspected window using eval().

  With every re-render, this object is updated with new measures and events count.
  The extension takes care of clearing up the memory (required to store this object) and also the cache.

  Calculating and aggregating the results happens inside the app frame and not in the devtool. It has its own benefits.
    * These measures can be send to a server for analyses
    * Measures can be logged to a console
    * Particular measures can be inspected in the console with the help of configuration object (not done with the API for it yet)
    * This also gives control to the developer on how to manage and inspect the measures apart from using the extension

  Trade-offs of previous version:
    * Need to update the commonjs react-dom development bundle (commenting the line)
    * No way of sending the measures from the app frame to the console
    * Need to query measures rather than listening to an event once
    * No control on how to inspect the measures for a particular use case (for eg - render and update performance of a component)

  Options, passed to listener:
    * log (log to console)
    * port (port number to send the data to console)

  Callback (optional): A callback can also be passed. The callback receives the parsed and aggregated results of the performance measures.

  NOTE: This should only be used in development mode.
*/
var registerObserver = function registerObserver(params, callback) {
  params = params || {};

  // TODO: Is there any way to polyfill this API ?
  if (window.PerformanceObserver) {
    var _params = params,
        shouldLog = _params.shouldLog,
        port = _params.port,
        components = _params.components;


    var observer = new window.PerformanceObserver(function (list) {
      var measures = (0, _generate.generateDataFromMeasures)((0, _parse.getReactPerformanceData)(list.getEntries()));

      if (callback && typeof callback === 'function') {
        callback(measures);
      }

      window.__REACT_PERF_DEVTOOL_GLOBAL_STORE__ = {
        measures: measures,
        length: list.getEntries().length,
        rawMeasures: list.getEntries()

        // For logging to console
      };if (shouldLog) {
        logToConsole(params, measures);
      }
    });

    observer.observe({
      entryTypes: ['measure']
    });
  }
};

/**
  This function logs the measures to the console. Requires a server running on a specified port. Default port number is 8080.
  TODO: Change this behaviour if Chrome lands the support for recording performance when inspecting the node apps.
*/
var logToConsole = function logToConsole(_ref, measures) {
  var port = _ref.port,
      components = _ref.components;

  if (!components) {
    logMeasures(port, measures);
  } else if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) !== undefined && Array.isArray(components)) {
    var requiredMeasures = getRequiredMeasures(components, measures);

    logMeasures(port, requiredMeasures);
  }
};

var logMeasures = function logMeasures(port, measures) {
  measures.forEach(function (_ref2) {
    var componentName = _ref2.componentName,
        mount = _ref2.mount,
        render = _ref2.render,
        update = _ref2.update,
        unmount = _ref2.unmount,
        totalTimeSpent = _ref2.totalTimeSpent,
        percentTimeSpent = _ref2.percentTimeSpent,
        numberOfInstances = _ref2.numberOfInstances,
        componentWillMount = _ref2.componentWillMount,
        componentDidMount = _ref2.componentDidMount,
        componentWillReceiveProps = _ref2.componentWillReceiveProps,
        shouldComponentUpdate = _ref2.shouldComponentUpdate,
        componentWillUpdate = _ref2.componentWillUpdate,
        componentDidUpdate = _ref2.componentDidUpdate,
        componentWillUnmount = _ref2.componentWillUnmount;

    // The time is in millisecond (ms)
    // TODO: The data generated is generalized. Make it concrete!
    var data = {
      component: componentName,
      mount: mount,
      render: render,
      update: update,
      unmount: unmount,
      totalTimeSpent: totalTimeSpent,
      percentTimeSpent: percentTimeSpent,
      numberOfInstances: numberOfInstances,
      componentWillMount: componentWillMount,
      componentDidMount: componentDidMount,
      componentWillReceiveProps: componentWillReceiveProps,
      shouldComponentUpdate: shouldComponentUpdate,
      componentWillUpdate: componentWillUpdate,
      componentDidUpdate: componentDidUpdate,
      componentWillUnmount: componentWillUnmount
    };

    send(data, port);
  });
};

// Send the data to a specified port
var send = function send(data, port) {
  window.navigator.sendBeacon('http://127.0.0.1:' + (port !== undefined && typeof port === 'number' ? port : 8080), JSON.stringify(data, null, 2));
};

var getRequiredMeasures = function getRequiredMeasures(components, measures) {
  var requiredMeasures = [];

  if (!Array.isArray(components)) {
    components = [components];
  }

  measures.forEach(function (measure) {
    if (components.includes(measure.componentName)) {
      requiredMeasures.push(measure);
    }
  });

  return requiredMeasures;
};

exports.registerObserver = registerObserver;