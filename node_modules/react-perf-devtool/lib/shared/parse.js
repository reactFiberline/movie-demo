'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getReactPerformanceData = undefined;

var _parseMeasures = require('./parseMeasures');

// Schema for storing the time duration of each phase of a React component
var createSchema = function createSchema() {
  return {
    // Phases
    mount: {
      timeSpent: []
    },
    unmount: {
      timeSpent: []
    },
    update: {
      timeSpent: []
    },
    render: {
      timeSpent: []
    },

    // Lifecycle hooks
    componentWillMount: {
      timeSpent: []
    },
    componentDidMount: {
      timeSpent: []
    },
    componentWillReceiveProps: {
      timeSpent: []
    },
    shouldComponentUpdate: {
      timeSpent: []
    },
    componentWillUpdate: {
      timeSpent: []
    },
    componentDidUpdate: {
      timeSpent: []
    },
    componentWillUnmount: {
      timeSpent: []
    }
  };
};

// Update the time duration of each phase
var updateTime = function updateTime(store, componentName, phase, measure) {
  if (phase === '[mount]') {
    store[componentName].mount.timeSpent.push(measure.duration);
  }

  if (phase === '[unmount]') {
    store[componentName].unmount.timeSpent.push(measure.duration);
  }

  if (phase === '[update]') {
    store[componentName].update.timeSpent.push(measure.duration);
  }

  if (phase === '[render]') {
    store[componentName].render.timeSpent.push(measure.duration);
  }

  if (phase === 'componentWillMount') {
    store[componentName].componentWillMount.timeSpent.push(measure.duration);
  }

  if (phase === 'componentWillUnmount') {
    store[componentName].componentWillUnmount.timeSpent.push(measure.duration);
  }

  if (phase === 'componentDidMount') {
    store[componentName].componentDidMount.timeSpent.push(measure.duration);
  }

  if (phase === 'componentWillReceiveProps') {
    store[componentName].componentWillReceiveProps.timeSpent.push(measure.duration);
  }

  if (phase === 'shouldComponentUpdate') {
    store[componentName].shouldComponentUpdate.timeSpent.push(measure.duration);
  }

  if (phase === 'componentWillUpdate') {
    store[componentName].componentWillUpdate.timeSpent.push(measure.duration);
  }

  if (phase === 'componentDidUpdate') {
    store[componentName].componentDidUpdate.timeSpent.push(measure.duration);
  }
};

// Get data from the performance measures
var getReactPerformanceData = function getReactPerformanceData(measures) {
  var store = {};

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = measures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var measure = _step.value;

      if ((0, _parseMeasures.getComponentAndPhaseName)(measure) !== null) {
        var _getComponentAndPhase = (0, _parseMeasures.getComponentAndPhaseName)(measure),
            componentName = _getComponentAndPhase.componentName,
            phase = _getComponentAndPhase.phase;

        if (!store[componentName]) {
          store[componentName] = createSchema();
        }

        updateTime(store, componentName, phase, measure);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return store;
};

exports.getReactPerformanceData = getReactPerformanceData;